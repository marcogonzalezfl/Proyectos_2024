# Instalación de paquetes necesarios
!pip install earthengine-api
!pip install geemap
!pip install numpy
!pip install pandas
!pip install matplotlib
!pip install seaborn

# Importaciones necesarias
import ee
import geemap
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import logging
from typing import Dict, Optional

# Configurar logging con formato detallado
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# Autenticación de Earth Engine
ee.Authenticate()
ee.Initialize()

class LandsatAnalyzer:
    """
    Clase para analizar imágenes Landsat y calcular riesgo de incendios
    """
    
    def __init__(self):
        """Inicializar el analizador de imágenes Landsat"""
        try:
            ee.Initialize()
            logging.info("Earth Engine inicializado correctamente")
        except Exception as e:
            logging.error(f"Error inicializando Earth Engine: {str(e)}")
            raise e

    def create_region_from_points(self, coordinates: list) -> ee.Geometry:
        """
        Crear polígono de región de interés desde coordenadas
        
        Parámetros:
        -----------
        coordinates : list
            Lista de coordenadas [longitud, latitud]
        """
        try:
            if coordinates[0] != coordinates[-1]:
                coordinates.append(coordinates[0])
            return ee.Geometry.Polygon([coordinates])
        except Exception as e:
            logging.error(f"Error creando región: {str(e)}")
            return None

    def get_landsat_image(self, region: ee.Geometry, start_date: str, end_date: str) -> ee.Image:
        """
        Obtener imagen Landsat 8 más reciente con menor cobertura de nubes
        
        Parámetros:
        -----------
        region : ee.Geometry
            Región de interés
        start_date : str
            Fecha inicial (YYYY-MM-DD)
        end_date : str
            Fecha final (YYYY-MM-DD)
        """
        try:
            # Filtrar colección de imágenes
            collection = ee.ImageCollection('LANDSAT/LC08/C02/T2_L2') \
                .filterBounds(region) \
                .filterDate(start_date, end_date) \
                .filter(ee.Filter.lt('CLOUD_COVER', 20))

            count = collection.size().getInfo()
            
            if count > 0:
                image = collection.sort('CLOUD_COVER').first()
                
                # Obtener metadatos
                date = ee.Date(image.get('system:time_start')).format('YYYY-MM-dd').getInfo()
                cloud_cover = image.get('CLOUD_COVER').getInfo()
                landsat_scene = image.get('LANDSAT_SCENE_ID').getInfo()
                
                # Logging de información
                self._log_image_info(date, cloud_cover, landsat_scene, start_date, end_date, count)

                return image
            
            logging.warning("No se encontraron imágenes disponibles")
            return None
                
        except Exception as e:
            logging.error(f"Error obteniendo imagen: {str(e)}")
            return None

    def _log_image_info(self, date: str, cloud_cover: float, scene_id: str, 
                       start_date: str, end_date: str, count: int) -> None:
        """Método auxiliar para logging de información de imagen"""
        logging.info("\n=== Información de la Imagen Satelital ===")
        logging.info(f"Satélite: Landsat 8")
        logging.info(f"Colección: T2_L2")
        logging.info(f"Escena: {scene_id}")
        logging.info(f"Fecha de captura: {date}")
        logging.info(f"Cobertura de nubes: {cloud_cover:.1f}%")
        logging.info(f"Período analizado: {start_date} a {end_date}")
        logging.info(f"Imágenes disponibles: {count}")

    def analyze_image_coverage(self, image: ee.Image, region: ee.Geometry) -> Optional[ee.Number]:
        """
        Analizar cobertura de la imagen y píxeles válidos
        
        Parámetros:
        -----------
        image : ee.Image
            Imagen Landsat a analizar
        region : ee.Geometry
            Región de interés
        """
        try:
            # Crear máscara de nubes y sombras
            qa = image.select('QA_PIXEL')
            cloud_mask = qa.bitwiseAnd(1 << 3).eq(0)
            shadow_mask = qa.bitwiseAnd(1 << 4).eq(0)
            valid_mask = cloud_mask.And(shadow_mask)
            
            # Calcular píxeles totales y válidos
            total_pixels = ee.Number(image.select('SR_B4').reduceRegion(
                reducer=ee.Reducer.count(),
                geometry=region,
                scale=30,
                maxPixels=1e9
            ).get('SR_B4'))
            
            valid_pixels = ee.Number(image.select('SR_B4').updateMask(valid_mask).reduceRegion(
                reducer=ee.Reducer.count(),
                geometry=region,
                scale=30,
                maxPixels=1e9
            ).get('SR_B4'))
            
            # Obtener valores y logging
            total = total_pixels.getInfo()
            valid = valid_pixels.getInfo()
            
            self._log_coverage_info(total, valid)
            
            return valid_pixels
            
        except Exception as e:
            logging.error(f"Error analizando cobertura de imagen: {str(e)}")
            return None

    def _log_coverage_info(self, total: int, valid: int) -> None:
        """Método auxiliar para logging de información de cobertura"""
        logging.info("\n=== Análisis de Cobertura de Imagen ===")
        logging.info(f"Píxeles totales en la imagen: {total:,}")
        logging.info(f"Píxeles válidos (sin nubes/sombras): {valid:,}")
        logging.info(f"Porcentaje de píxeles válidos: {(valid/total*100):.1f}%")
        logging.info(f"Píxeles no válidos: {total-valid:,}")
        logging.info(f"Área cubierta (km²): {(valid * 0.0009):,.2f}")

    def calculate_indices(self, image: ee.Image) -> ee.Image:
        """
        Calcular índices espectrales (NBR, NDVI, NDMI)
        
        Parámetros:
        -----------
        image : ee.Image
            Imagen Landsat para calcular índices
        """
        try:
            # Definir bandas y nombres
            BANDS_CONFIG = {
                'bands': ['SR_B4', 'SR_B5', 'SR_B6', 'SR_B7'],
                'newNames': ['RED', 'NIR', 'SWIR1', 'SWIR2']
            }
            
            # Escalar imagen
            image_scaled = image.select(BANDS_CONFIG['bands'], 
                                      BANDS_CONFIG['newNames']).multiply(0.0000275).add(-0.2)
            
            # Calcular índices
            nbr = image_scaled.normalizedDifference(['NIR', 'SWIR2']).rename('NBR')
            ndvi = image_scaled.normalizedDifference(['NIR', 'RED']).rename('NDVI')
            ndmi = image_scaled.normalizedDifference(['NIR', 'SWIR1']).rename('NDMI')
            
            indices = ee.Image.cat([nbr, ndvi, ndmi])
            
            logging.info("\n=== Índices Calculados ===")
            logging.info("- NBR (Normalized Burn Ratio)")
            logging.info("- NDVI (Normalized Difference Vegetation Index)")
            logging.info("- NDMI (Normalized Difference Moisture Index)")
            
            return indices
            
        except Exception as e:
            logging.error(f"Error calculando índices: {str(e)}")
            return None

    def sample_points(self, indices: ee.Image, region: ee.Geometry) -> Dict:
        """
        Muestrear puntos en la región
        
        Parámetros:
        -----------
        indices : ee.Image
            Imagen con índices calculados
        region : ee.Geometry
            Región de interés
        """
        try:
            # Configuración de muestreo
            SAMPLE_CONFIG = {
                'scale': 30,
                'numPixels': 5000,
                'seed': 123,
                'tileScale': 16
            }
            
            points = indices.sample(
                region=region,
                scale=SAMPLE_CONFIG['scale'],
                numPixels=SAMPLE_CONFIG['numPixels'],
                seed=SAMPLE_CONFIG['seed'],
                geometries=True,
                dropNulls=True,
                tileScale=SAMPLE_CONFIG['tileScale']
            )
            
            values = points.getInfo()
            logging.info("\n=== Muestreo de Puntos ===")
            logging.info(f"Puntos muestreados: {len(values['features'])}")
            
            return values
            
        except Exception as e:
            logging.error(f"Error en muestreo: {str(e)}")
            return None

    def analyze_risk(self, sample_data: Dict) -> pd.DataFrame:
        """
        Analizar riesgo de incendio con intervalos fijos
        
        Parámetros:
        -----------
        sample_data : Dict
            Diccionario con datos muestreados
        """
        try:
            # Configuración de análisis de riesgo
            RISK_CONFIG = {
                'weights': {'NBR': 0.4, 'NDMI': 0.3, 'NDVI': 0.3},
                'bins': [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
                'labels': ['Muy Bajo', 'Bajo', 'Medio', 'Alto', 'Muy Alto']
            }
            
            # Crear DataFrame eficientemente
            features = sample_data['features']
            data = []
            for f in features:
                props = f['properties']
                coords = f['geometry']['coordinates']
                props.update({'longitude': coords[0], 'latitude': coords[1]})
                data.append(props)
            
            df = pd.DataFrame(data)
            
            # Calcular FRI usando operaciones vectorizadas
            nbr_component = RISK_CONFIG['weights']['NBR'] * (-df['NBR'] + 1) / 2
            ndmi_component = RISK_CONFIG['weights']['NDMI'] * (-df['NDMI'] + 1) / 2
            ndvi_component = RISK_CONFIG['weights']['NDVI'] * (1 - df['NDVI']) / 2
            
            df['FRI'] = nbr_component + ndmi_component + ndvi_component
            df['FRI'] = df['FRI'].clip(0, 1)
            
            # Clasificar riesgo
            df['Riesgo_Categoria'] = pd.cut(
                df['FRI'],
                bins=RISK_CONFIG['bins'],
                labels=RISK_CONFIG['labels'],
                include_lowest=True
            )
            
            self._log_risk_analysis(df)
            return df
            
        except Exception as e:
            logging.error(f"Error en análisis de riesgo: {str(e)}")
            logging.error(f"Detalles del error: {str(e.__class__.__name__)}")
            return None

    def _log_risk_analysis(self, df: pd.DataFrame) -> None:
        """Método auxiliar para logging del análisis de riesgo"""
        logging.info("\n=== Análisis de Riesgo ===")
        logging.info(f"Puntos analizados: {len(df):,}")
        
        # Logging de rangos de índices
        indices = ['NBR', 'NDVI', 'NDMI', 'FRI']
        logging.info("\nRango de valores de índices:")
        for idx in indices:
            logging.info(f"{idx}: [{df[idx].min():.3f}, {df[idx].max():.3f}]")
        
        # Distribución de categorías
        logging.info("\nDistribución por categorías:")
        categoria_counts = df['Riesgo_Categoria'].value_counts().sort_index()
        for cat, count in categoria_counts.items():
            pct = (count/len(df))*100
            logging.info(f"{cat}: {count:,} puntos ({pct:.1f}%)")

def graficos():
    """
    Generar visualizaciones del análisis de riesgo
    
    Genera cuatro gráficos:
    1. Distribución de categorías de riesgo
    2. Relación entre NDVI y NBR
    3. Histograma del FRI
    4. Distribución espacial del riesgo
    """
    try:
        # Configuración de visualización
        PLOT_CONFIG = {
            'figsize': (15, 10),
            'colors': ['#2ecc71', '#82e0aa', '#f4d03f', '#f5b041', '#ec7063'],
            'category_bounds': [0, 0.2, 0.4, 0.6, 0.8, 1.0],
            'category_labels': ['Muy Bajo', 'Bajo', 'Medio', 'Alto', 'Muy Alto'],
            'dpi': 300,
            'pad': 3.0
        }
        
        # Leer datos
        df = pd.read_csv('resultados_riesgo_paraguay.csv')
        
        # Configurar estilo
        plt.style.use('default')
        
        # Crear figura con subplots
        fig = plt.figure(figsize=PLOT_CONFIG['figsize'])
        
        # 1. Gráfico de barras - Distribución de categorías
        ax1 = plt.subplot(2, 2, 1)
        _plot_category_distribution(ax1, df, PLOT_CONFIG)
        
        # 2. Scatter plot - NDVI vs NBR
        ax2 = plt.subplot(2, 2, 2)
        _plot_indices_scatter(ax2, df)
        
        # 3. Histograma de FRI
        ax3 = plt.subplot(2, 2, 3)
        _plot_fri_histogram(ax3, df, PLOT_CONFIG)
        
        # 4. Distribución espacial
        ax4 = plt.subplot(2, 2, 4)
        _plot_spatial_distribution(ax4, df)
        
        # Ajustar layout y guardar
        plt.tight_layout(pad=PLOT_CONFIG['pad'])
        plt.savefig('analisis_riesgo_incendio.png', 
                   dpi=PLOT_CONFIG['dpi'], 
                   bbox_inches='tight')
        
        # Logging y estadísticas
        _log_plot_info(df)
        
        # Mostrar gráficos
        plt.show()
        
    except Exception as e:
        logging.error(f"Error generando gráficos: {str(e)}")
        logging.error(f"Detalles: {str(e.__class__.__name__)}")

def _plot_category_distribution(ax, df, config):
    """Graficar distribución de categorías de riesgo"""
    riesgo_counts = df['Riesgo_Categoria'].value_counts().sort_index()
    bars = ax.bar(range(len(riesgo_counts)), 
                 riesgo_counts.values, 
                 color=config['colors'])
    
    ax.set_title('Distribución de Categorías de Riesgo\n(Intervalos Fijos)', pad=20)
    ax.set_xlabel('Categoría de Riesgo')
    ax.set_ylabel('Número de Puntos')
    ax.set_xticks(range(len(riesgo_counts)))
    ax.set_xticklabels(riesgo_counts.index, rotation=45)
    
    # Agregar valores y porcentajes
    total_points = len(df)
    for bar in bars:
        height = bar.get_height()
        percentage = (height / total_points) * 100
        ax.text(bar.get_x() + bar.get_width()/2., height,
                f'{int(height)}\n({percentage:.1f}%)',
                ha='center', va='bottom')

def _plot_indices_scatter(ax, df):
    """Graficar scatter plot de índices"""
    scatter = ax.scatter(df['NDVI'], df['NBR'], 
                        c=df['FRI'], 
                        cmap='RdYlGn_r', 
                        alpha=0.6)
    plt.colorbar(scatter, ax=ax, label='Índice de Riesgo de Incendio (FRI)')
    ax.set_title('NDVI vs NBR', pad=20)
    ax.set_xlabel('NDVI')
    ax.set_ylabel('NBR')
    ax.grid(True, linestyle='--', alpha=0.7)

def _plot_fri_histogram(ax, df, config):
    """Graficar histograma de FRI"""
    ax.hist(df['FRI'], bins=20, color='skyblue', edgecolor='black')
    
    # Agregar líneas verticales y etiquetas
    for i, bound in enumerate(config['category_bounds']):
        ax.axvline(x=bound, color='red', linestyle='--', alpha=0.5)
        if i < len(config['category_bounds']) - 1:
            x_pos = (bound + config['category_bounds'][i+1]) / 2
            ax.text(x_pos, ax.get_ylim()[1], 
                   config['category_labels'][i],
                   ha='center', va='bottom', rotation=0)
    
    ax.set_title('Distribución del FRI\ncon Límites de Categorías', pad=20)
    ax.set_xlabel('Índice de Riesgo de Incendio (FRI)')
    ax.set_ylabel('Frecuencia')
    ax.grid(True, linestyle='--', alpha=0.7)

def _plot_spatial_distribution(ax, df):
    """Graficar distribución espacial del riesgo"""
    scatter = ax.scatter(df['longitude'], df['latitude'], 
                        c=df['FRI'], 
                        cmap='RdYlGn_r', 
                        s=50, alpha=0.6)
    plt.colorbar(scatter, ax=ax, label='Índice de Riesgo de Incendio (FRI)')
    ax.set_title('Distribución Espacial del Riesgo', pad=20)
    ax.set_xlabel('Longitud')
    ax.set_ylabel('Latitud')
    ax.grid(True, linestyle='--', alpha=0.7)

def _log_plot_info(df):
    """Logging de información de gráficos y estadísticas"""
    logging.info("\n=== Gráficos Generados ===")
    logging.info("Archivo guardado: analisis_riesgo_incendio.png")
    
    logging.info("\n=== Estadísticas de Índices ===")
    for indice in ['NBR', 'NDVI', 'NDMI', 'FRI']:
        stats = df[indice].describe()
        logging.info(f"\nEstadísticas de {indice}:")
        logging.info(f"Media: {stats['mean']:.3f}")
        logging.info(f"Desv. Est.: {stats['std']:.3f}")
        logging.info(f"Mín: {stats['min']:.3f}")
        logging.info(f"Máx: {stats['max']:.3f}")

def main():
    """Función principal de ejecución"""
    try:
        # Definir región de interés
        coordinates = [
            [-24.9, -57.0],    # Noreste
            [-24.9, -57.8],    # Noroeste
            [-26.1, -57.0],    # Sureste
            [-26.1, -57.8]     # Suroeste
        ]

        # Inicializar analizador
        analyzer = LandsatAnalyzer()
        region = analyzer.create_region_from_points(coordinates)
        logging.info("Región creada")

        # Definir período de análisis
        end_date = datetime.now()
        start_date = end_date - timedelta(days=30)
        
        # Obtener y analizar imagen
        image = analyzer.get_landsat_image(
            region,
            start_date.strftime('%Y-%m-%d'),
            end_date.strftime('%Y-%m-%d')
        )

        if image is not None:
            # Análisis de cobertura
            analyzer.analyze_image_coverage(image, region)
            
            # Cálculo de índices y muestreo
            indices = analyzer.calculate_indices(image)
            sample_data = analyzer.sample_points(indices, region)
            
            # Análisis de riesgo y guardado de resultados
            if sample_data is not None:
                results_df = analyzer.analyze_risk(sample_data)
                
                if results_df is not None:
                    filename = 'resultados_riesgo_paraguay.csv'
                    results_df.to_csv(filename, index=False)
                    logging.info(f"\nResultados guardados en: {filename}")

    except Exception as e:
        logging.error(f"Error en ejecución principal: {str(e)}")

if __name__ == "__main__":
    main()
    graficos()
